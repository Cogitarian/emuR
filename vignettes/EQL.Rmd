---
title: "Version 2 of the Emu Query Language"
affiliation: "Institute Of Phonetic And Speech Processing (LMU Munich)"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_width: 6
bibliography: vignettes.bib
vignette: >
  %\VignetteIndexEntry{Version 2 of the Emu Query Language}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# WARNING: DOCUMENT STILL BEING WRITTEN!

# Introduction

This document introduces and defines version 2 of the **E**mu **Q**uery **L**anguage (**EQL**) and tries to show what it is capable of by giving numerous examples. The EQL is a query language that is aimed at speech and language researchers that is supposed to be easy to understand and learn yet expressive and powerful. It enables researchers to easily query annotation structures of databases stored in the emuDB format. The `emuR` package provides a `query()` function to query emuDBs that are loaded into the current R session (for more information see the `emuR_intro` as well as the `emuDB` vignettes). The main argument of the `query()` function is the `query` argument (`query(..., query = "XXX", ...)` where `XXX` is the query string). In this document we will be focusing soley on these query and how to compile them.  

To revise what was already mentioned in the `emuR_intro` as well as the `emuDB` vignette: The annotation structure of an `emuDB` can be thought of as a graph. Each annotation consist of annotational units (called ITEMs) that are grouped together in an ordered array. Each ITEM can be linked to other ITEMs of other levels if an according linkDefinition is present in the `emuDB`. An exemplary excerpt of such an annotation can be seen below.

![Alt text](pics/msajc003.svg)

As we will not be mentioning it throughout the rest of the vignette: one thing to note about the `query()` function are the parameters `bundlePattern` and `sessionPattern`. These can be used to restrict which session and bundle the query will be run against. They both expect a regular expression string to restrict the sessions or bundles one wishes to query.

# Examples

We will now jump right in by giving you a bunch of examples of query strings that where adapted from [@harrington:2002, @cassidy_harrington:2001].

## Simple equality / unequality / matching / non-matching queries (single argument)

The syntax of a simple equality / unequality / matching / non-matching query is `"[L OPERAND A]"` where "L" specifies a level (or alternatively the name of a parallel attributeDefinitions), "OPERAND" is one of the following operands: "==" (equality); "!=" (unequality); "=~" (matching) or "!~" (non-matching) and "A" is an expression specifying the labels of the ITEMs of "L".

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "m" in the "Phonetic" level?*
    - **A**: `"[Phonetic == m]"`
- **Q**: *What is the query string to retrieve all ITEMs containing the label "m" or "n" in the "Phonetic" level?*
    - **A**: `"[Phonetic == m | n]"`
- **Q**: *What is the query string to retrieve all ITEMs that don't contain the label "m" or "n"?*
    - **A**: `"[Phonetic != m | n]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Syllable" level?*
    - **A**: `"[Syllable =~ .*]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Text" level beginning with 'fi'?*
    - **A**: `"[Text =~ fi.*]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Text" level that don't begin with 'fi'?*
    - **A**: `"[Text !~ fi.*]"`


**INFO: The above examples use three operands that are new to the EQL as of version 2. One beeing the "==" equal operand that has the same meaning as the "=" operand of the EQL1 (which is also still available) while providing a cleaner more precise syntax. The other two being the "=~" and "!~" which are the new matching and non-matching regular expression operands.**

## Sequence queries using the "->" sequence operand

The syntax of a query string using the "->" sequence operand is `"[L == A -> L == B]"` where ITEM "A" on level "L" precedes ITEM "B" on level "L". For a sequential query to work both arguments must be on the same level (alternatively parallel attributeDefinitions of the same level may also be chosen).
   
Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all sequences of ITEMs containing the label "m" followed by ITEMs containing the label "I" on the "Phonetic" level?*
    - **A**: `"[Phonetic == m -> Phonetic == I]"` (all row entries in the resulting segment list have the start time of "m" and end time of "I" and the labels will be "m->I")
- **Q**: *Same as the question above but this time we are only interested in the ITEMs containing the label "m" of the sequences.*
    - **A**: `"[#Phonetic == m -> Phonetic == I]"`  (all row entries in the resulting segment list have the start time of "m" and the end time of "m" and the labels will be "m")  
- **Q**: *Same as the first question but this time we are only interested in the ITEMs containing the label "I".*
    - **A**: `"[Phonetic == m -> #Phonetic == I]"` (all row entries in the resulting segment list have the start time of "I" and the end time of "I" and the labels will be "I")  

### Subsequent sequence queries using nesting of the "->" sequence operand   

The general strategy to constructing a query string that retrieves subsequent sequences of labels is to nest multiple sequences while paying close attention to the correct placement of the parentheses. An abstracted version of such a query string for the subsequent sequence of arguments A1, A2, A3, A4 would be: `"[[[[A1-> A2] -> A3] -> A4] -> A5]"` where each argument (e.g. "A1") represents an equality / unequality / matching / non-matching expression on the same level (alternatively parallel attributeDefinitions of the same level may also be chosen).

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all sequences of ITEMs containing ["m" "I" "n"] labels on the "Phonetic" level?*
    - **A**: `"[[Phonetic == m -> Phonetic == I ] -> Phonetic == n]"` 
- **Q**: *What is the query string to retrieve all sequences of ITEMs containing ["john"" "could" "lend"] labels on the "Text" level?*
    - **A**: `"[[Text == john -> Text == could] -> Text == lend]"`
- **Q**: *What is the query string to retrieve all sequences of ITEMs containing labels "the" followed by two arbitrary labels followed by "managed"?*
    - **A**: `"[[[Text == the -> Text =~ .*] -> Text =~ .* ] -> Text == managed]"`

**INFO: As the EQL1 didn't have a regular expression operand, users often resorted to using queries such as "[Phonetic != XXX]" (where XXX is a label that was not part of the label set of the "Phonetic" level) to match every label on the "Phonetic" level. Although this is still possible in the EQL2, we strongly recommend using regular expressions as they provide a much clearer and preciser syntax and are less error prone.**


## The conjunction operand &

The syntax of a query string using the conjunction operand can schematically be written as: `"[L1 == A & L2 == B & L3 == C & L4 == D & ... & Ln == N]"` where all "A" ITEMs on level "L1" also have the properties "B", "C", "D", ..., "N". Same as with the sequence operand all expressions must be on the same level (parallel attributeDefinitions of the same level may also be chosen).

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "S" on the "Syllables" level which also have the label "L+H\*" on a parallel attributeDefintion called "Pitch\_Accent"?*
    - **A**: `"[Syllable == S & Pitch_Accent == L+H*]"`
- **Q**: *What is the query string to retrieve all ITEMs of the attributeDefintion "Text" of the level "Word" that where also labeled to be function words (labeled "F" in the "Word" level)?*
    - **A**: `"[Text =~ .* & Word == F]"`
- **Q**: *What is the query string to retrieve all ITEMs of the attributeDefintion "Text" of the level "Word" that where also labeled to be content words (labeled "C" in the "Word" level) and labeled to be accentuated (labeled "S" in the attributeDefintion "Accent" of the same level)?*
    - **A**: `"[Text =~ .* & Word == C & Accent == S]"`


## Domination operand ^ (== hierarchical queries)

A schematic representation of a simple domination query string that retrieves all ITEMs "A" of level "L1" that are dominated by i.e. are directly or indirectly linked to ITEMs "B" in level "L2" would be `"[L1 == A ^ L2 == B]"`. The dominates operand is not directional, meaning that either ITEMs in "L1" dominate ITEMs in "L2" or ITEMs in "L2" dominate ITEMs in "L1". Note that linkDefinitions that specify the validity of the domination have to be present in the emuDB for this to work (see `emuDB` vignette for details).

### Simple Domination

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "p" in the "Phoneme" level that occur in strong syllables (i.e. dominated by / linked to ITEMs of the level "Syllable" that contain the label "S")?*
    - **A**: `"[Phoneme == p ^ Syllable == S]"`
- **Q**: *What is the query string to retrieve all syllable ITEMs which contain a phoneme ITEM labeled "p"?*
    - **A**: `"[Syllable =~ .* ^ Phoneme == p]"` or `"[Phoneme == p ^ #Syllable =~ .*]"`
- **Q**: *What is the query string to retrieve all syllable ITEMs which neither contain a phoneme ITEM labeled "k" nor "p" nor "t"?*
    - **A**: `"[Syllable =~ .* ^ Phoneme != p | t | k]"` or `"[Phoneme != p | t | k ^ #Syllable =~ .*]"`

**INFO: Even though the domination operand is not directional, what you place to the left and to the right of the operand does have an impact on the result. If no result modifier (the hash tag "#") is used the query engine will automaticall assume that the expression to the left of the operand specifies what is to be returned. This means that the schematic query string: `"[L1 == A ^ L2 == B]"` is semantically equal to the query string: `"[#L1 == A ^ L2 == B]"`. As it is more explicit to mark the desired result expression we recommend you always use the result modifier in query strings.**

### Multiple Domination

The general strategy to constructing a query string that specifies multiple domination relations of ITEMs is to nest multiple domination expressions while paying close attention to the correct placement of the parentheses. A dominance relationship sequence "A1", "A2", "A3", "A4", can therefore be noted as:  `"[[[[A1 ^ A2] ^ A3] ^ A4] ^ A5]"`.

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs on the "Pitch_Accent" level that where labeled "H\*" that contain a phoneme "p" and belong to the words "price" or "space"?*
    - **A**: `"[[Pitch_Accent == H\* ^ Phoneme == p] ^ Text == price | space]"`
- **Q**: *The same as the question above but this time we want the appropriate words.*
    - **A**: `"[[Pitch_Accent == H* ^ Phoneme == p] ^ #Text == price | space]"`


## Position

The EQL has four function terms to specify where in a dominance relationship a child level ITEM is allowed to occur. The four function terms are "Start()", "End()", "Medial()" and "Num()".

### Simple usage of Start(), End() and Medial()

A schematic representation of a query string representing a simple usage of the "Start()", "End()" and "Medial()" function would be: `"POSFCT(L1, L2) == 1"`. In this representation "POSFCT" is a placeholder for one of the three function where the level "L1" conditionally dominates level "L2". The "== 1" part of the query string indicates that if a match is found (match is `TRUE` or "== 1") then the according ITEM of the level "L2" is returned. If this expression is set to "== 0" (`FALSE`), all the ITEMs that do not match the condition of "L2" will be returned. For a visualization of what is returned by the various options of the three functions see the illustration below.

![Alt text](pics/positionSimple.svg)

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all word-initial syllables?*
    - **A**: `"[Start(Word, Syllable) == 1]"`
- **Q**: *What is the query string to retrieve all word-initial phonemes?*
    - **A**: `"[Start(Word, Phoneme) == 1]"`
- **Q**: *What is the query string to retrieve all non-word-initial syllables?* 
    - **A**: `"[Start(Word, Syllable) == 0]"`
- **Q**: *What is the query string to retrieve all word-final syllables?* 
    - **A**: `"[End(Word, Syllable) == 1]"`
- **Q**: *What is the query string to retrieve all word-medial syllables?* 
    - **A**: `"[Medial(Word, Syllable) == 1]"`
    
### Position and Boolean &

The syntax for combining a position function with the boolean operand is `"[L == E & Start(L1, L2) == 1]"` where ITEM E on level L occurs at the beginning of L1. Once again L1 has to dominate L2 as well as being on the same level (parallel attributeDefinitions of the same level may also be chosen). 

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all "p" phonemes at the beginning of a syllable?*
    - **A**: `"[Phoneme == p & Start(Syllable, Phoneme) == 1]"`  
- **Q**: *What is the query string to retrieve all word-final "m" phonemes?*
    - **A**: `"[Phoneme == m & End(Word, Phoneme) == 1]"`
- **Q**: *What is the query string to retrieve all non-word-final "S" syllables which are labeled with tonic accent L+H\*?*
    - **A**: `"[Syllable == S & Pitch_Accent == L+H* & (Word, Syllable) == 0]"`

### Position and Boolean ^

The syntax for combining a position function with the boolean hierarchical operand is `"[L == E ^ Start(L1, L2) == 1]"` where level "L" and level "L2" refer to different levels where either "L" dominates "L2", or "L2" dominates "L".

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all "p" phonemes, which occur in the first syllable of the word?*
    - **A**: `"[Phoneme == p ^ Start(Word, Syllable) == 1]"`
- **Q**: *What is the query string to retrieve all phonemes, which do not occur in the last syllable of the word?*
    - **A**: `"[Phoneme =~ .* ^ End(Word, Syllable) == 0]"`

## Count

Syntax: `"[Num(L1, L2) == N]"`
Semantics: L1 contains N L2 ITEMs
Condition: La dominates Lb. n is a number
Note: Generates segment list on La (not on Lb, as with 4-syllable words position)
**`[Num(Word, Syllable)=4]`**  
There are also the operators > (more than), < (less than) and != (not equal).  
Syllables, which have more than 6 phonemes
**`[Num(Syllable, Phoneme)>6]`**  
and so on  

### Count and Boolean &

Syntax: **L = e & Num(La, Lb) = n**  
Semantics: Element e on level L is dominated by La ; and La contains n Lb elements, La dominates Lb  
Condition: (L and La (not Lb!) are on the same level or linear level).  

- Text of all words, which consist of 11 phonemes: `"[Text!=x & Num(Text, Phoneme) > 11 ] ="` or  `"[Text =~ .* & Num(Word, Phoneme) > 11]"`
- H\* tonic accents in syllables of 5 phonemes:  `"[Pitch_Accent = H* & Num(Syllable, Phoneme) = 5]"`

### Count and ^

Syntax/Semantics as with 6.2, but:
If L and La are different levels (L dominates La, or La dominates L) use ^ instead of & :

- All m phonemes in 4-syllable words  `"[Phoneme == m ^ Num(Word, Syllable) == 4]"`
- All W-Syllables in words of 3 or less syllables `"[Syllable = W ^ Num(Word, Syllable) < 3]"`
- All words, which contain syllable, which contain 4 phonemes  `[Text != x ^ Num(Syllable, Phoneme) == 4]"`

## Combinations

### ^ and -> (Domination and Sequence)  
Condition: The sequence -> must connect only same or levels or linear levels! (See 2.)
`"[[a1 ^ a2] -> a3] [a1 -> [a2 ^ a3]]"`

- m precedes I and m is part of a S-syllable  `"[[Phoneme = m -> Phoneme = I] ^ Syllable=S]"`
- s precedes p and p is part of a W-syllable  `"[Phoneme = s -> [Phoneme = p ^ Syllable = W]]"`
- all S-syllables, which contain phoneme p and precede a S-syllable  `"[[Syllable = S ^ Phoneme = p] -> Syllable = S]"`
- but now we want p: p is part of a S-syllable and this S-syllable precedes a S-syllable: `"[[Phoneme = p ^ Syllable = S] -> Syllable = S]"`
- Not allowed! Because Phoneme = p and Syllable = S are not on the same level, therefore:  `"[[Syllable = S ^ #Phoneme=p] -> Syllable = S]"`

### ^ and -> and & (Domination and Sequence and Boolean &)

Words, beginning with a schwa:  
**`[Text!=x ^ Phoneme = @ & Start(Text, Phoneme)=1]`**
A word-beginning m in a string syllable, which precedes I  
**`[[Phoneme = m & Start(Word, Phoneme)=1 -> Phoneme=I] ^ Syllable=S]`**  
same but we want the text:  
**`[[[Phoneme = m & Start(Word, Phoneme)=1 -> Phoneme=I] ^ Syllable=S] ^ #Text!=x]`**
The text of all three-syllable words, which contain a schwa in the first syllable; these three-syllable words must precede ‘the’
The text of all three-syllable words  
1. Text!=x & Num(Text, Syllable)=3  
Schwa occurs in the first syllable  
2. Phoneme=@ ^ Start(Word, Syllable)=1  
The text is ‘the’  
3. Text = the  
[1 ^ 2]  
[[1 ^ 2] -> 3]

**`[[Text!=x & Num(Text, Syllable) =3 ^ [Phoneme=@ ^ Start(Word, Syllable)=1]] -> Text=the ]`**  

## A few more Q & A's

To revisit the various points lets go through a few typical questions and their respective answers.

- **Q**: *What is the query string to retrieve all "m" or "n" phonemes, which occur in the word-medial position?*
    - **A**: `"[Phoneme == m | n & Medial(Word, Phoneme) == 1]"`
- **Q**: *What is the query string to retrieve all "H" phonetic segments, next an arbitrary segment, next either "I" or "U"?*
    - **A**: `"[[Phonetic == H -> Phonetic != x ] -> Phonetic == I | U ]"`
- **Q**: *What is the query string to retrieve all syllables, which do not occur in the word-medial position?*
    - **A**: `"[Syllable != x & Medial(Word, Syllable) == 0]"`
- **Q**: *What is the query string to retrieve the text of all words, which contain two syllables?*
    - **A**: `"[Text != x & Num(Text, Syllable) == 2]"`
- **Q**: *What is the query string to retrieve the text of all accentuated words following "the"?*.  
    - **A**: `"[Text == the -> #Text != x & Accent == S]"`
- **Q**: *What is the query string to retrieve all "S" (strong) syllables consisting of 5 phonemes?*
    - **A**: `"[Syllable = S ^ Num(Word, Phoneme) == 5]"`
- **Q**: *What is the query string to retrieve all "W" (weak) syllables, which contain a "@" phoneme?*
    - **A**: `"[Syllable == W ^ Phoneme == @]"`
- **Q**: *What is the query string to retrieve the text of words, which contain either a "L\*" or "L\+H\*"" tonic accent?*  
    - **A**: `"[Text =~ .* ^ Pitch_Accent == L* | L+H*]"`
- **Q**: *What is the query string to retrieve all "H\*" tonic accents of word-final syllables, which occur in three-syllable words?*
    - **A**: `"[Pitch_Accent == H* & End(Word, Syllable) == 1 ^ Num(Word, Syllable) == 3]"`
- **Q**: *What is the query string to retrieve all phonemes, dominating Phonetic ITEMs "H", at the beginning of a syllable; and which occur in accentuated (S) words?*
    - **A**: `"[[[Phoneme!=x ^ Phonetic = H] ^ Start(Word, Syllable)=1] ^ Accent = S]"`


# Differences and incompatibilities to legacy EMU query language (R package 'emu', version 4.2)

In this section we will try to give a quick overview of the major changes concerning the query mechanics of `emuR` compared to the legacy R package `emu` in the version 4.2. This is mainly meant for people transitioning to `emuR` from the legacy system.

## Function call syntax

In `emuR` it is required that a emuDB is loaded into your current R session before beeing able to use the `query()` function. This is achieved using the `load_emuDB()` function (see `emuR_intro` vignette for details). This was not necessary using the legacy `emu.query()` function.

EQL2 `query()` function is part of R package emuR. See `help(query)`

Examples:

```
query("andosl", "[Phoneme == p ^ Syllable == S]")
```

Session and bundle selection patterns are optional and expect regular expression pattern strings.

Example:

```
query("andosl", "[Phoneme == p ^ Syllable == S]", sessionPattern = "000.", bundlePattern = "msajc0[1-2].")
```

In this case the sessionPattern parameter has no effect as the "andosl" is an emuDB that only has the dummy session "0000". The bundlePattern parameter however selects only bundles starting with 'msajc01' or 'msajc02'.


## Result type

The new default result type of a query is an object of the S3 class "emuRsegs". This class inherits from the legacy EMU class "emusegs" and the well known "data.frame" class. This means it is fully compatible to the legacy "emusegs" class, while containing some additional data, for example the ID's of the start and end ITEMs of each segment list row. Each row of this "data.frame" is a sequence of one or more annotational units (i.e. ITEMs) on a single level. For more information about this object see `help(emuRsegs)`.

The `query` function of `emuR` returns an empty segment list (row count is zero) if the query does not match any ITEM. If the legacy EMU function `emu.query()` didn't find any matches it would throw an error of the form: `"Can't find the query results in emu.query: there may have been a problem with the query command."`.

## Bundle (utterance) names

The `emuDB` format used by the `emuR` package introduces the concept of bundles that are grouped together in sessions (see `emuDB` vignette for further details). As legacy EMU databases did not have the concept of a session, all the utterances of a legacy database are place in a single default session called "0000". Therefore the "utts" column of a segment list is prefixed by the session name for example "0000:msajc003" instead of just being "msajc003" as in the legacy system.

## The result modifier hash tag '#'

Compared to the legacy EMU system which allowed multiple occurrences of the hash tag "#" to be present in a query, the `query()` function only allows a single result modifier. This assures that only consistent result sets are returned. If you however desire to have multiple result sets in one segment list, we recommend you simply  concatenate the result sets of separate queries using the `rbind()` function.

## Interpretation of the hash tag "#" conjunction operand queries
#### legacy Emu

```
> emu.query('andosl','*','[Text=spring & #Accent=S]')
moving data from Tcl to R
Read 1 records
segment  list from database:  andosl 
query was:  [Text=spring & #Accent=S] 
  labels    start      end     utts
1 spring 2288.959 2704.466 msajc094

> emu.query('andosl','*','[#Text=spring & #Accent=S]')
moving data from Tcl to R
Read 1 records
segment  list from database:  andosl 
query was:  [#Text=spring & #Accent=S] 
  labels    start      end     utts
1 spring 2288.959 2704.466 msajc094
```

The hash tag "#" had no effect.

#### emuR
```
> query(andosl,"[Text == spring & #Accent == S]", resultType == "emusegs")
segment  list from database:  andosl 
query was:  [Text=spring & #Accent=S] 
  labels    start      end          utts
1      S 2288.975 2704.475 0000:msajc094
```

Returns the same ITEM, but with the label of the hashed attributeDefinition name.
The second legacy example is not a valid `emuR` query (two hash tags).

```
> query('andosl',"[#Text=spring & #Accent=S]")

 Error in query.database.eql.KONJA(dbConfig, qTrim) : 
  Only one hashtag allowed in linear query term: #Text=spring & #Accent=S 
```

The `query()` function throws an error as it would be necessary to return each item twice to get both the "Text" and "Accent" labels.

## Bugs in legacy EMU function emu.query

### Alternative labels in unequality queries

Example:

#### (legacy) EMU

```
> emu.query('ae','*',"[Text!=beautiful|futile ^ Phoneme=u:]")
moving data from Tcl to R
Read 4 records
segment  list from database:  ae 
query was:  [Text!=beautiful|futile ^ Phoneme=u:] 
     labels    start      end     utts
1       new  475.802  666.743 msajc057
2    futile  571.999 1091.000 msajc010
3        to 1091.000 1222.389 msajc010
4 beautiful 2033.739 2604.489 msajc003
```

We assume that the OR operand "|" was simply ignored when used in conjunction with the unequality operand "!=".

#### emuR

```
> query(ae,"[Text != beautiful | futile ^ Phoneme == u:]", resultType = "emusegs")
segment  list from database:  ae 
query was:  [Text!=beautiful|futile ^ Phoneme=u:] 
  labels    start      end          utts
1     to 1091.025 1222.375 0000:msajc010
2    new  475.825  666.725 0000:msajc057
```

### Errors caused by missing or superfluous blanks / parenthesis

Certain queries in the legacy EMU system required blanks around certain operands to be present or absent as well as certain parenthesis to be present or absent. If this was not the case the query engine threw cryptic errors or sometimes even crashed and in the worst case took the entire R session with it. The query engine of the `emuR` package is much more robust against missing or superfluous blank / parenthesis.

### Order of result segment list

It is unknown if legacy Emu returns the seglist ordered.
emuR returns emuRsegs result lists ordered by UUID, session, bundle and sample start position and emusegs lists by the fields utts and start.

### Additional features

emuR accepts also the double equal character string '==' as equal operator.

emuR EQL2 has the capability to query labels by matching regular expressions using the '=~' (match) and '!~' (not match) operators.

#### Example
```
> query('andosl',"Text=~.*tz.*")
segment  list from database:  andosl 
query was:  Text=~.*tz.* 
   labels    start      end session   bundle startItemID endItemID type
1 blitzed 1586.875 2112.475    0000 msadb081          54        54 ITEM
2 blitzed 1540.225 2022.475    0000 msajc081          59        59 ITEM
```


# Extended Backus–Naur Form (EBNF)

EBNF adapted from [@john:2012a]. As the original EBNF was formulated in German a few of the abbreviation terms (e.g. "DOMA" is German abbreviation for "**Dom**inanz**a**bfrage") where translated into English abbreviations (e.g. "DOMQ" is an English abbreviation for "**dom**inance **q**uery").

## Terminal symbols of EQL2 (operators) and their meaning.

The terminal symbols described below are ordered descending by their binding priority.

| Operator | Meaning |
| --- | --- |
| `#` | Result modifier (projection) |
| `,` | Parameter list separator |
| `==` | Equality (new in version 2 of the EQL; for cleaner syntax)|
| `=` | Equality (optional; for backwards compatibility)|
| `!=` | Unequality |
| `=~` | Regular expression match |
| `!~` | Regular expression not match |
| `>` | Greater than |
| `>=` | Equal or greater than  |
| `<` | Less than |
| `>=` | Equal or less than |
| `|` | Alternatives separator |
| `&` | Conjunction of equal rank |
| `^` | Dominanceconjunction |
| `->` | Sequenceoperator |

## Terminal symbols of EQL2 (brackets) and their meaning.

| Bracket | Meaning |
| --- | --- |
| `'` | Quotes literal string |
| `(` | Function parameter list begin |
| `)` | Function parameter list end |
| `[` | Sequence or dominance enclosing begin bracket  |
| `]` | Sequence or dominance enclosing end bracket |

## Terminal symbols of EQL2 (functions) and their meaning

| Function | Meaning |
| --- | --- |
| `Start` | Start | 
| `Medial` | Medial |
| `End` | Final |
| `Num` | Count |

## Nearly complete formal description of EMU query language EQL2

+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| EBNF term                                                                         | Abriviation                        | Conditions                                    |
+===================================================================================+====================================+===============================================+
| `EQL = CONJQ | SEQQ | DOMQ;`                                                      | **E**MU **Q**uery **L**anguage     |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `DOMQ = "[", ( CONJQ | DOMQ | SEQQ ), "^", ( CONJQ | DOMQ | SEQQ ), "]";`         | **dom**inance **q**uery            | levels must be hierarchically associated      |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `SEQQ = "[", ( CONJQ | SEQQ | DOMQ ), "->", ( CONJQ | SEQQ | DOMQ ), "]";`        | **seq**uential **q**uery           | levels must be linearly associated            |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `CONJQ = { "[" }, SQ, { "&", SQ }, { "]" };`                                      | **conj**unction **q**uery          | levels must be linearly associated            |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `SQ = LABELQ | FUNCQ;`                                                            | *s*imple *q*uery                   |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABELQ = [ "#" ], LEVEL, ( "=" | "==" | "!=" | "=~" | "!~" ), LABELALTERNATIVES;`| **label** **q**uery                |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `FUNCQ = POSQ | NUMQ;`                                                            | **fun**ction **q**uery             |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `POSQ = POSFCT, "(", LEVEL, ",", LEVEL, ")", "=", "0" | "1";`                     | **position** **q**uery             | levels must be hierarchically associated;     |
|                                                                                   |                                    | second level determines semantic              |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `NUMQ = "Num", "(", LEVEL, ",", LEVEL, ")", COP, INTPN;`                          | **number**  **q**uery              | levels must be hierarchically associated;     |
|                                                                                   |                                    | first level determines semantic               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABELALTERNATIVES = LABEL , { "|", LABEL };`                                     | **label alternatives**             |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABEL= LABELING | ( "'", LABELING, "'" );`                                       | **label**                          | levels must be part of the database structure;|
|                                                                                   |                                    | LABELING is an arbitrary character string or a|
|                                                                                   |                                    | label group class configured in the emuDB;    |
|                                                                                   |                                    | result modifier '#' may only occur once       |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `POSFCT = "Start" | "Medial" | "End";`                                            | **pos**ition **f**un**ct**ion      |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `COP = "=" | "==" | "!=" | ">" | "<" | "<=" | ">=";`                              | **c**omparison **o**perand         |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `INTPN = "0" | INTP;`                                                             |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `INTP = DIGIT-"0", { DIGIT };`                                                    |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";`              | **digit**                          |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+



## Restrictions 

A query can only contain a single result modifier "#" (hash tag)


# References