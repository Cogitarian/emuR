---
title: "emuDB: The database format of the next iteration of the EMU speech database management system"
author: "Raphael Winkelmann"
affiliation: "Institute Of Phonetic And Speech Processing (LMU Munich)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: vignettes.bib
vignette: >
  %\VignetteIndexEntry{autobuild tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
  
# WARNING: DOCUMENT STILL BEING WRITTEN!

# Introduction

This document introduces the emuDB format that is used by the emuR package and shows how to create and interact with this database format. The emuDB format is meant as a simple, general purpose way of storing speech databases that may contain complex hierarchical annotations as well as derived and complementary speech data.

# DB design

The database structure is basically a set of files and folders that adhere to a certain structure and naming convention (see Figure below).

![Alt text](pics/db_structure.svg) 

The database root directory contains a single `_DBconfig.json` file which, as the name implies, contains the configuration options of the database such as its level definitions, how these levels are linked in the database hierarchy and what is displayed in the EMU-webApp. The database root folder also contains session folders (ending with `_ses`). These session folders can be used to logically group the `_bndl` folders described below.

Each session folder can contain any number of `_bndl` folders. All the files belonging to a bundle, for example a recorded sentence, are stored in the corresponding bundle folder. This includes the actual recording (`.wav`) and derived signal files in the SSFF format [@cassidy:2013a] such as formants (`.fms`) or the fundamental frequency (`.f0`), both of which can be generated using the `wrassp` package. Each bundle folder also contains the annotation file (`_annot.json`) of that bundle. This file, as the name implies, contains the actual annotations including the hierarchical linking information. JSON schema files are provided to ensure the syntactic integrity of the database (*https://github.com/IPS-LMU/EMU-webApp/tree/master/dist/schemaFiles*). The following naming restrictions apply:

* the database folder has to have the same name as the `_DBconfig.json` prefix
* all session folders must be named including the suffix `_ses`. Their prefixes can be chosen by the database maintainer.
* all bundle folders must be named including suffix `_bndl`. Their prefixes can be chosen by the database maintainer.
* all files within a bundle that belong to the bundle have to have the same basename as the `_bndl` folder prefix

Files that do not follow this naming convention will simply be ignored by the database interaction functions of the `emuR` package.

Optional files that may also be included in the database root directory are the `_bundleList.json` files. These files specify which annotator is assigned to which bundles. These files are used by EMU-websocket-protocol servers that implement user management to assign the correct bundles to the annotators. The serve functions implemented in the `emuR` package DO NOT support user management which means that these files will simply be ignored.

For more detailed information about the file formats used see the "File descriptions" section of this document.
    

# Creating a emuDB

There are multiple ways of creating emuDBs. The two main strategies in creating a database are to either convert existing databases or file collection to the new format or to create new databases from scratch. Both strategies are described below.

## Converting existing databases

The emuR package provides a function for converting existing legacyEmuDBs to the new emuDB format. Here is an example of how to use this function:

```{r}
# load the package
library(emuR)
# get the path to a .tpl file of a legacyEmuDB that comes with the emuR package
path2extdata = system.file("extdata", package = "emuR")
tplPath = list.files(path2extdata, pattern=glob2rx('*.tpl'), full.names=TRUE, recursive = T)
# convert this legacyEmuDB to the emuDB format
convert_legacyEmuDB_to_emuDB(emuTplPath = tplPath, targetDir = tempdir(), verbose = F)
```

This will create a new emuDB in the folder provided by `tempdir()` containing all the information specified in the `.tpl` file. The name of the new emuDB is the same as the basename of the `.tpl` file from which it was generated.  

A further function provided is the `convert_TextGridCollection_to_emuDB()` function. This function converts an existing `.TextGrid` & `.wav` file collection to the emuDB format. To be able to pair the correct files together the `.TextGrid` files as well as the `.wav` files must have the same basename (== file name without extension). A further restriction is that the tiers contained within all the `.TextGrid` files have to be equal in name & type (equal subsets can be chosen using the `tierNames` argument of the function). As an example if all `.TextGrid` files contain the tiers `Syl: IntervalTier`, `Phonetic: IntervalTier` and `Tone: TextTier` the conversion will work, if a single `.TextGrid` of the collection has the additional tier `Word: IntervalTier` the conversion will fail but can be made to work by specifying the equal subset `equalSubset = c('Syl', 'Phonetic', 'Tone')` and passing it into the function argument `tierNames`. 

```{r}
# get the path to a folder containing .wav & .TextGrid files that come with the package
path2extdata = system.file("extdata", package = "emuR")
path2folder = file.path(path2extdata, 'legacy_emu')

# convert this TextGridCollection to the emuDB format
convert_TextGridCollection_to_emuDB(path2folder, dbName = 'newDbName', 
                                    targetDir = tempdir(), verbose = F)
```

This will create a new emuDB in the folder `tempdir()` called 'newDbName'. The emuDB will contain all the tier information of the `.TextGrid` files but without hierarchical information as `.TextGrid` files do not contain any linking information. To generate links between the generated `SEGMENTS` and `EVENTS` see the **Autobuild** section in this document.


## Creating a emuDB from scratch

To create an emuDB from scratch simply call:

```{r}
create_emuDB(name = 'fromScratchDB', 
             targetDir = tempdir(), 
             verbose=F)
```

This will create an empty emuDB that does not have any ssffTrackDefinitions or levelsDefinitions as well as not containing any sessions or bundles. Adding these to the emuDB is described in the next section.

# Manipulating a database

The initial step in manipulating or generally interacting with a database is to load the according database into your current R session. People interested in the way the emuR package caches the database are referred to the **emuDB caching** section of this document.

```{r}
# generate path to the empty fromScratchDB created above
dbPath = file.path(tempdir(), 'fromScratchDB')
# load database
dbName = load_emuDB(dbPath, verbose = F)
print(dbName)
```

This will load the database into it's cached form for quick access to the data. Note that if a large emuDB has never been loaded and no cache has previously been generated, this can take a while to complete. Once a cache is present only altered annotation files have to be updated with reduces load times dramatically. As you can see the `load_emuDB()` function returns the name of the database. This name is used to reference the loaded database in most database interaction functions of the emuR package. If you have multiple emuDBs loaded these can be listed by calling:

```{r}
list_emuDBs()
```

The emuR package contains two function to purge (==unload/remove) loaded databases from the current R session. These functions are `purge_emuDB()` and `purge_all_emuDBs()`. We will not invoke these functions here as we still wish to manipulate the loaded database. A further thing to note is that if name collisions of loaded databases occur one can still access the loaded databases using their names as well as an additional unique identifier that each emuDB has called the UUID. This UUID is also listed by the `list_emuDBs()` function.

The general function prefix naming convention of database manipulation functions for loaded databases are:

- `add_XXX` add a new instance of `XXX` / `set_` set the current instance of `XXX`
- `list_XXX` list the current instances of `XXX` / `get_` list the current instance of `XXX`
- `modify_XXX` modify existing instances of `XXX`
- `remove_XXX` removing existing instances of `XXX`

Depending on the instance that you wish to manipulate some or all of these functions will be present.

## Level definitions

Compared to other system the EMU speech database management system requires the user to formally define the structure of the database. An essential stuctural element of any emuDB are it's levels. A level is a more general term for what is often referred to as a "tier". It is more general in the sense that people quite often expect tiers to contain time information. Levels can either contain time information if they are either of the type "EVENT" or of the type "SEGMENT" or be timeless if they are of the type "ITEM".

As the already loaded 'fromScratchDB' does not contain any structural elements including levels we will begin by adding a new level definition:

```{r}
add_levelDefinition(dbName, 
                    name = 'Phonetic', 
                    type = 'SEGMENT')
```

To check if this action was successful we can simply list the current level definitions by calling:

```{r}
list_levelDefinitions(dbName)
```

If we wish to change the name/type of the level we have just added to the database we can invoke:   

```{r}
# modify (rename to lower case)
modify_levelDefinition(dbName, 
                       name = 'Phonetic', 
                       newName='phonetic')
# list
list_levelDefinitions(dbName)
```

*NOTE: If there are actual instances of annotation items present in the emuDB this will not be possible. These would first have to be removed.*

Let us add a further levelDefinition that will contain the orthographic word transcriptions for the words uttered in our recordings. This level will be of the type `ITEM` meaning that elements contained within the level are ordered but do not contain any time information:

```{r}
# add
add_levelDefinition(dbName, 
                    name = 'Word', 
                    type = 'ITEM')
# list
list_levelDefinitions(dbName)
```

Finally we could remove one of the levelDefinitions with the function `remove_levelDefinition()`, which we will once again not invoke here as we still wish to use these levelDefinitions. 

### Attribute definitions

Each levelDefinition can contain multiple attributes, the most common attribute being a label (`"type": "STRING"`). Due to this it is possible to have multiple parallel labels in a single level. This means that a single annotation item can contain multiple labels while sharing other properties such as the start and duration information. This can be quite handy in modeling certain types of data. A illustrative example of this would be the 'phonetic' level created above. It is often the case that databases contain both the phonetic transcript using IPA UTF-8 symbols as well as using the Speech Assessment Methods Phonetic Alphabet (SAMPA). This is a perfect choice for using multiple attributeDefinitions within a single level:

```{r}
# list
list_attributeDefinitions(dbName, 
                          levelName = 'phonetic')
```

Even though we have not added a single attribute definition to the 'phonetic' level definition. It already contains the obligatory attribute definition that has to have the same name as it's level, indicating that it is the primary attribute of that level. To follow the above example let us now add a further attribute definition to the level definition that will contain the SAMPA versions of our annotations.

```{r}
# add
add_attributeDefinition(dbName, 
                        levelName = 'phonetic', 
                        newName = 'SAMPA')
# list
list_attributeDefinitions(dbName, 
                          levelName = 'phonetic')
```



#### Legal labels 

As you might have guessed from seeing the columns `hasLabelGroups` and `hasLegalLabels` in the return value of the `list_attributeDefinitions()` function, attributeDefinitions can also contain two further fields. The `legalLabels` field contains an array of strings that specifies the labels that are legal (== allowed/valid) for the given attribute. As the EMU-webApp won't allow the annotator to enter any labels that are not specified in this array this is a simple way assuring that a level has a concistent label set.

As an example lets say we wish to only annotate the following vowels in the `phonetic` level: /i/, /iː/, /u/, /uː/, /ə/ which in SAMPA correspont to /i/, /i:/, /u/, /u:/, /@/. Let us now add these as legal labels to the `phonetic` as well as the `SAMPA` attribute of the `phonetic` level.

```{r}

ipaVowels = c('i', 'iː', 'u', 'uː', 'ə')

sampaVowels = c('i', 'i:', 'u', 'u:', '@')

# set legalLabels values for phonetic attributeDefinition
set_legalLabels(dbName,
                levelName = 'phonetic',
                attributeDefinitionName = 'phonetic',
                legalLabels = ipaVowels)

# get
get_legalLabels(dbName, 
                levelName = 'phonetic', 
                attributeDefinitionName = 'phonetic')

# set legalLabels values for phonetic attributeDefinition
set_legalLabels(dbName,
                levelName = 'phonetic',
                attributeDefinitionName = 'SAMPA',
                legalLabels = sampaVowels)

# get
get_legalLabels(dbName, 
                levelName = 'phonetic', 
                attributeDefinitionName = 'SAMPA')

```


*NOTE: The legalLabels field is volunary! This means that if it is not set the level can contain any label.*

#### Label groups  

TODO write about label groups field

## Link definitions

Todo write

## File handeling

Up until now we have defined the structure of our database. An essential part that is missing is of course the recordings that we wish to analyse. To import audio files, referred to as media files in the context of an emuDB, into the database one simply has to do the following:

```{r}
# get path to folder containing wav files 
# (in this case wav files that come with the wrassp package)
fp = system.file('extdata', package='wrassp')
# import media files into emuDB session called wrassp
import_mediaFiles(dbName, 
                  dir = fp, 
                  targetSessionName = 'filesFromWrassp', 
                  verbose = F)
# list session
list_sessions(dbName)
# list bundles
list_bundles(dbName)
```

We have now added a new session called 'filesFromWrassp' to the 'fromScratchDB' containing a new bundle for each of our imported media files. These bundles adhere to the structure we have specified above. Note however that the levels in the annotation files (`_annot.json`) that where created during the import are still empty. These will have to be created manually using the EMU-webApp. To list the files that are part of the emuDB simply:

```{r}
# show head of list_files
head(list_files(dbName))
```

The emuR package also provides a mechanism to add files to preexisting bundle folders as, due to the nested folder structure of an emuDB, this can be quite tedious to perform manually. Let us create a set of files that contain the zero-crossing-rate values of the wav files we added above and for the sake of demonstration save them to a different location to then re-add them to the database.

```{r}
# list all wav files in new emuDB
wavFilePaths = list.files(dbPath, 
                          pattern = "wav$", 
                          full.names = T, 
                          recursive = T)
# create folder to store zcr values in
outDirPath = file.path(tempdir(), 'zcranaVals')
dir.create(outDirPath)
# calculate zero-crossing-rate files
# using zcrana function of wrassp package
zcrana(listOfFiles = wavFilePaths, 
       outputDirectory = outDirPath)
# add zcr files to emuDB
add_files(dbName, 
          dir = outDirPath, 
          fileExtension = 'zcr',
          targetSessionName = 'filesFromWrassp')
# show head of list_files to check if files where added
head(list_files(dbName))
```


## SSFF track definitions

A further important structural element of any emuDB are the so called ssffTracks (often simply refered to as tracks). These ssffTracks reference data that is stored in the **S**imple **S**ignal **F**ile **F**ormat (**SSFF**) in the according `_bndl` folders. The two main types of data are:

- what is often referred to as complimentary data that was acquired during the recording such as data acquired during **e**lectro**m**agnetic **a**rticulographic (**EMA**) or **e**lectro**p**alato**g**raphy (**EPG**) recordings. 
- what is often referred to as derived data meaning data that was calculated from the original audio signal such as formant values and their bandwidths or the short-term Root Mean Square amplitude of the signal.

Let us now add an ssffTrackDefinition to our database calculating the according SSFF files on-the-fly:

```{r}
# add track and calculate SSFF files by specifying 
# one of the signal processing functions the wrassp package provides
# (in this case the forest (formant estimation) function)
add_ssffTrackDefinition(dbName, 
                        name = 'formantValues', 
                        columnName = 'fm', 
                        fileExtension = 'fms',
                        onTheFlyFunctionName = 'forest')
# list
list_ssffTrackDefinitions(dbName)
# show head of list_files to check if files where added
head(list_files(dbName))
```

**INFO: to see the fileExtension and columnName default produced by the various signal processing functions of the wrassp package see `?wrasspOutputInfos`**

As you might have noticed the `.zcr` files we added in the previous section are listed as beeing part of the bundles but have no ssffTrackDefinition associated with them. Let's fix that by adding another ssffTrackDefinition to the database:

```{r}
# add 
add_ssffTrackDefinition(dbName, 
                        name = 'zeroCrossing', 
                        columnName = 'zcr', 
                        fileExtension = 'zcr')
# list
list_ssffTrackDefinitions(dbName)
```





*NOTE: due to the ability of the `get_trackdata()` function to utilize any of the signal processing functions of the wrassp package to calculate the necessary values on-the-fly it is quite often not necessary to define ssffTracks for tracks produced by the wrassp package. For complimentary data as well as when data that will be manually manipulated (e.g. manual formant corrections) this is still a feasible and necessary option. Also, if you wish to display SSFF data in the EMU-webApp it is necessary to precalculate the ssffTracks as the web application can not perform on-the-fly calculations.*




## Configuring the EMU-webApp

TODO: write how to configure the EMU-webApp

# Autobuilding
  
The annotation of large complex multileveled hierarchical speech databases is
a very time consuming laborious procedure. The *emuR* provides functions to
automate various bits of this procedure to help with this laborious task.

**emuDB**


The available function are:

- autobuild.linkFromTimes()
- autobuild.MapLevels()
- autobuild.Syllabify()



An important prereq: linkDefinition available!


## autobuild.linkFromTimes()

This function causes annotations at two levels *L1* and *L2* to be linked whenever the time(s) of the annotations at tier
*U* are within those of ttier *T*.


Given we have a a super-level of the form:

Lets load a demo database and add a new fake level to the database so we have
something to play with


```{r}
# load the package
# library(emuR)
# get the path to the ae database that comes with the package
# path2ae = system.file("extdata/emu/DBs/ae/", package = "emuR")
# load the database
# ae = load_emuDB(path2ae, verbose = F)
# plot the phonetic level
# add linkDef.
  #tmpLinkDef = create.schema.linkDefinition(type='ONE_TO_MANY', superlevelName='Phonetic', sublevelName='Tone')
  #ae$DBconfig$linkDefinitions[[length(ae$DBconfig$linkDefinitions) + 1]] = tmpLinkDef 


```

and a sub-level of the form:

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect width="100%" height="75" stroke-width="1" fill="#E7E7E7" stroke="rgb(0, 0, 0)" />
  <line x1="0" y1="0" x2="20%" y2="20%" fill="rgb(0, 0, 0)" stroke-width="5"  />
</svg>

- ONE\_TO\_MANY
- MANY\_TO\_MANY
- ONE\_TO\_ONE

# File descriptions

## _DBconfig.json

The `DBconfig` file, as mentioned above, contains the configuration options of the database. People familiar with the legacy EMU system will recognize this to be the replacement file for the legacy template (`.tpl`) file. As is the convention in quite a few programming languages variables / strings written entierly in capital letters indicate a constant variable that usually has a special meaning. This is also the case with strings like this found in the `DBconfig` (`"STRING"`,`"ITEM"`,`"SEGMENT"`, `"EVENT"`, ... ).

The `_DBconfig.json` file contains the following fields:

* `"name"` specifying the name of the database
* `"UUID"` a unique ID given to each database
* `"mediafileExtension"` the main mediafileExtension (*currently only uncompressed mono 16-bit `.wav` files are supported in every component of the EMU system. This is also the recommended audio format for the EMU system.*)
* `"ssffTrackDefinitions"` an array of definitions defining the SSFF tracks of the database. Each ssffTrackDefinition consists out of:
    * `"name"` the name of the ssffTrackDefinition
    * `"columnName"` the name of the column of the associated SSFF file. For more information on the columns the various function of the `wrassp` produce see the track field of `wrasspOutputInfos` object that is part of the `wrassp` package. Further, although the SSFF file format is a binary file format it has a plain text header which means that if you open a SSFF file with the text editor of your choice you will be able to see the columns contained within it. A further option is to get column information about a specific SSFF file, is to use the `wrassp` function `res = read.AsspDataObj('/path/2/SSFF/file')` to read the file from the file system. `names(res)` will then give you the names of the columns present in this file. NOTE: In the context of the SSFF file format the term *column* and in the context of the EMU system the term *track*/*ssffTrack* is used. They both refer to the same data.
    * `"fileExtention"` the file extension of the associated SSFF file (also see `?wrasspOutputInfos` for the default extensions produced by the `wrassp` functions)
* `"levelDefinitions"`  array of definitions defining the levels of the database. A level is a more general term for what is often referred to as a tier. It is more general in the sense that people quite often associate tiers to contain time information. Levels can however either contain time information if they are of are either of the type `"EVENT"` or of the type `"SEGMENT"` but can also be timeless if they are of the type `"ITEM"`. Each "`levelDefinitions"` consists out of:
    * `"name"` the name of the levelDefinition
    * `"type"` specifying the type of the level (either `"ITEM"` | `"EVENT"` | `"SEGMENT"`)
    * `"attributeDefinitions"` an array of definitions defining the attributes of the level. Each attributeDefinition consists out of:
        * `"name"` the name of the `"attributeDefinition"`
        * `"type"` specifying the type of the attribute (currently only `"STRING"` permitted)
        * `"labelGroups"` an array containing label group definitions. These can be used as a shorthand notation for querying certain groups of labels.
            * `"name"` name of label group. This will be the value used in a query to refer to this group 
            * `"values"` array of strings representing the labels
        * `"legalLabels"` array of strings specifying which labels are valid/legal for this attribute definition. The EMU-webApp adheres to this set of values and will not let the annotator enter any other values than the ones specified in this field. This can be used to insure consistent label sets within levels.
    * `"anagestConfig"` if specified (optional) this will convert the level into a special type of level for labeling articulatory data. This will also invoke the EMU-webApp to treat this level differently. It is optional field may only be set for levels of type `"EVENT"`. For more information on handling articulatory data in the EMU system see XXX.
        * `"verticalPosSsffTrackName"` name of ssffTrack containing the vertical position data
        * `"velocitySsffTrackName"` name of ssffTrack containing the velocity data
        * `"autoLinkLevelName"` name of level that will be used to link the created events to
        * `"multiplicationFactor"` factor to multiply with (either `-1` | `1`)
        * `"threshold"` a value between 0 and 1 defining the threshold
        * `"gestureOnOffsetLabels"` array containing two strings that specify the on- and offset labels
        * `"maxVelocityOnOffsetLabels"` array containing two strings that specify the on- and offset labels
        * `"constrictionPlateauBeginEndLabels"` array containing two strings that specify the begin- and end labels
        * `"maxConstrictionLabel"` string specifying label
* `"linkDefinitions"`  an array of definitions defining the levels of the database. The combination of all link definition specifies the hierarchy of the database. Each ssffTrackDefinition consists of:
    * `"type"` specifying the type of link (either `"ONE_TO_MANY"` | `"MANY_TO_MANY"` | `"ONE_TO_ONE"`).
    * `"superlevelName"` specifies the name of the superlevel
    * `"sublevelName"` specifies the name of the sublevel
* `"labelGroups"` an array containing label group definitions. These can be used as a shorthand notation for querying certain groups of labels. Compared to the `"labelGroups"` that can be defined within a attributeDefinition the labelGroups defined here are globally defined for the entire database.
    * `"name"` name of label group. This will be the value used in a query to refer to this group 
    * `"values"` array of strings containing con
* `"EMUwebAppConfig"` specifies the configuration of the EMU-webApp to display the database. As the EMU-webApp has multiple configuration options please refer to it's manual (TODO ADD LINK!) for more information about it's configuration options.


# emuDB caching

TODO: Write about object relational mapping into sqlite DB 
