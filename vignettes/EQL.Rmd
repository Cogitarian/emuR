---
title: "Version 2 of the Emu Query Language"
affiliation: "Institute Of Phonetic And Speech Processing (LMU Munich)"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_width: 6
    fig_height: 6
bibliography: vignettes.bib
vignette: >
  %\VignetteIndexEntry{Version 2 of the Emu Query Language}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# WARNING: DOCUMENT STILL BEING WRITTEN!

# Introduction

This document introduces and defines version 2 of the **E**mu **Q**uery **L**anguage (**EQL**) and tries to show what it is capable of by giving numerous examples. The EQL is a query language that is aimed at speech and language researchers that is supposed to be easy to understand and learn yet expressive and powerful. It enables researchers to easily query annotation structures of databases stored in the emuDB format. The `emuR` package provides a `query()` function to query emuDBs that are loaded into the current R session (for more information see the `emuR_intro` as well as the `emuDB` vignettes). The main argument of the `query()` function is the `query` argument (`query(..., query = "XXX", ...)` where `XXX` is the query string). In this document we will be focusing soley on these query and how to compile them.  

To revise what was already mentioned in the `emuR_intro` as well as the `emuDB` vignette: The annotation structure of an `emuDB` can be thought of as a graph. Each annotation consist of annotational units (called ITEMs) that are grouped together in an ordered array. Each ITEM can be linked to other ITEMs of other levels if an according linkDefinition is present in the `emuDB`. An exemplary excerpt of such an annotation can be seen below.

![Alt text](pics/msajc003.svg)

As we will not be mentioning it thoughout the rest of the vignette: one thing to note about the `query()` function are the parameters `bundlePattern` and `sessionPattern`. These can be used to restrict which session and bundle the query will be run against. They both expect a regular expression string to restrict the sessions or bundles one wishes to query.

# Examples

We will now jump right in by giving you a bunch of examples of query strings that where adapted from [@harrington:2002, @cassidy_harrington:2001].

## Simple equality / unequality / matching / non-matching queries (single argument)

The syntax of a simple equality / unequality / matching / non-matching query is `"[L OPERAND A]"` where "L" specifies a level (or alternativly the name of a parallel attributeDefinitions), "OPERAND" is one of the following operands: "==" (equality); "!=" (unequality); "=~" (matching) or "!~" (non-matching) and "A" is an expression specifying the labels of the ITEMs of "L".

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "m" in the "Phonetic" level?*
    - **A**: `"[Phonetic == m]"`
- **Q**: *What is the query string to retrieve all ITEMs containing the label "m" or "n" in the "Phonetic" level?*
    - **A**: `"[Phonetic == m | n]"`
- **Q**: *What is the query string to retrieve all ITEMs that don't contain the label "m" or "n"?*
    - **A**: `"[Phonetic != m | n]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Syllable" level?*
    - **A**: `"[Syllable =~ .*]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Text" level beginning with 'fi'?*
    - **A**: `"[Text =~ fi.*]"`
- **Q**: *What is the query string to retrieve all ITEMs in the "Text" level that don't begin with 'fi'?*
    - **A**: `"[Text !~ fi.*]"`


**INFO: The above examples use three operands that are new to the EQL as of version 2. One beeing the "==" equal operand that has the same meaning as the "=" operand of the EQL1 (which is also still available) while providing a cleaner more precise syntax. The other two beeing the "=~" and "!~" which are the new matching and non-matching regular expression operands.**

## Sequence queries using the "->" sequence operand

The syntax of a query string using the "->" sequence operand is `"[L == A -> L == B]"` where ITEM "A" on level "L" precedes ITEM "B" on level "L". For a sequential query to work both arguments must be on the same level (alternativly parallel attributeDefinitions of the same level may also be chosen).
   
Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all sequences of ITEMs containing the label "m" followed by ITEMs containing the label "I" on the "Phonetic" level?*
    - **A**: `"[Phonetic == m -> Phonetic == I]"` (all row entries in the resulting segment list have the start time of "m" and end time of "I" and the labels will be "m->I")
- **Q**: *Same as the question above but this time we are only interessted in the ITEMs containing the label "m" of the sequences.*
    - **A**: `"[#Phonetic == m -> Phonetic == I]"`  (all row entries in the resulting segment list have the start time of "m" and the end time of "m" and the labels will be "m")  
- **Q**: *Same as the first question but this time we are only interessted in the ITEMs containing the label "I".*
    - **A**: `"[Phonetic == m -> #Phonetic == I]"` (all row entries in the resulting segment list have the start time of "I" and the end time of "I" and the labels will be "I")  

### Subsequent sequence queries using nesting of the "->" sequence operand   

The general strategy to constructing a query string that retrieves subsequent sequences of labels is to nest muliple sequences while paying close attention to the correct placement of the parentheses. An abstracted version of such a query string for the subsequent sequence of arguments A1, A2, A3, A4 would be: `"[[[[A1-> A2] -> A3] -> A4] -> A5]"` where each argument (e.g. "A1") represents an equality / unequality / matching / non-matching expression on the same level (alternativly parallel attributeDefinitions of the same level may also be chosen).

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all sequences of ITEMs containing ["m" "I" "n"] labels on the "Phonetic" level?*
    - **A**: `"[[Phonetic == m -> Phonetic == I ] -> Phonetic == n]"` 
- **Q**: *What is the query string to retrieve all sequences of ITEMs containing ["john"" "could" "lend"] labels on the "Text" level?*
    - **A**: `"[[Text == john -> Text == could] -> Text == lend]"`
- **Q**: *What is the query string to retrieve all sequences of ITEMs containging labels "the" followed by two arbitrary labels followed by "managed"?*
    - **A**: `"[[[Text == the -> Text =~ .*] -> Text =~ .* ] -> Text == managed]"`

**INFO: As the EQL1 didn't have a regular expression operand, users often resorted to using queries such as "[Phonetic != XXX]" (where XXX is a label that was not part of the label set of the "Phonetic" level) to match every label on the "Phonetic" level. Although this is still possible in the EQL2, we strongly recommend using regular expressions as they provide a much clearer and preciser syntax and are less error prone.**


## The conjunction operand &

The syntax of a query string using the conjunction operand can schematically be written as: `"[L1 == A & L2 == B & L3 == C & L4 == D & ... & Ln == N]"` where all "A" ITEMs on level "L1" also have the properties "B", "C", "D", ..., "N". Same as with the sequence operand all expressions must be on the same level (parallel attributeDefinitions of the same level may also be chosen).

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "S" on the "Syllables" level which also have the label "L+H\*" on a parallel attributeDefintion called "Pitch\_Accent"?*
    - **A**: `"[Syllable == S & Pitch_Accent == L+H*]"`
- **Q**: *What is the query string to retrieve all ITEMs of the attributeDefintion "Text" of the level "Word" that where also labeled to be function words (labeled "F" in the "Word" level)?*
    - **A**: `"[Text =~ .* & Word == F]"`
- **Q**: *What is the query string to retrieve all ITEMs of the attributeDefintion "Text" of the level "Word" that where also labeled to be content words (labeled "C" in the "Word" level) and labeled to be accentuated (labeled "S" in the attributeDefintion "Accent" of the same level)?*
    - **A**: `"[Text =~ .* & Word == C & Accent == S]"`


## Domination operand ^ (== hierarchical queries)

A schematic representation of a simple domination query string that retrieves all ITEMs "A" of level "L1" that are dominated by i.e. are directly or indirectly linked to ITEMs "B" in level "L2" would be `"[L1 == A ^ L2 == B]"`. The dominates operand is not directional, meaning that either ITEMs in "L1" dominate ITEMs in "L2" or ITEMs in "L2" dominate ITEMs in "L1". Note that linkDefinitions that specify the validity of the domination have to be present in the emuDB for this to work (see `emuDB` vignette for details).

### Simple Domination

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs containing the label "p" in the "Phoneme" level that occur in strong syllables (i.e. dominated by / linked to ITEMs of the level "Syllable" that contain the label "S")?*
    - **A**: `"[Phoneme == p ^ Syllable == S]"`
- **Q**: *What is the query string to retrieve all syllable ITEMs which contain a phoneme ITEM labeled "p"?*
    - **A**: `"[Syllable =~ .* ^ Phoneme == p]"` or `"[Phoneme == p ^ #Syllable =~ .*]"`
- **Q**: *What is the query string to retrieve all syllable ITEMs which neither contain a phoneme ITEM labeled "k" nor "p" nor "t"?*
    - **A**: `"[Syllable =~ .* ^ Phoneme != p | t | k]"` or `"[Phoneme != p | t | k ^ #Syllable =~ .*]"`

**INFO: Even though the domination operand is not directional, what you place to the left and to the right of the operand does have an impact on the result. If no result modifier (the hash tag "#") is used the query engine will automaticall assume that the expression to the left of the operand specifies what is to be returned. This means that the schematic query string: `"[L1 == A ^ L2 == B]"` is semantically equal to the query string: `"[#L1 == A ^ L2 == B]"`. As it is more explicit to mark the desired result expression we recommend you always use the result modifier in query strings.**

### Multiple Domination

The general strategy to constructing a query string that specifies multiple dominaiton relations of ITEMs is to nest muliple domination expressions while paying close attention to the correct placement of the parentheses. A dominance relationship sequence "A1", "A2", "A3", "A4", can therefore be noted as:  **[[[[A1 ^ A2] ^ A3] ^ A4] ^ A5]**.

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all ITEMs on the "Pitch_Accent" level that where labeled "H\*" that contain a phoneme "p" and belong to the words "price" or "space"?*
    - **A**: `"[[Pitch_Accent == H\* ^ Phoneme == p] ^ Text == price | space]"`
- **Q**: *The same as the question above but this time we want the appropriate words.*
    - **A**: `"[[Pitch_Accent == H* ^ Phoneme == p] ^ #Text == price | space]"`


## Position

The EQL has four function terms to specify where in a dominance relationship a child level ITEM is allowed to occur. The four function terms are "Start()", "End()", "Medial()" and "Num()".

### Simple usage of Start(), End() and Medial()

A schematic representation of a query string representing a simple usage of the "Start()", "End()" and "Medial()" function would be: `"POSFCT(L1, L2) == 1"`. In this representation "POSFCT" is a placeholder for one of the three function where the level "L1" conditionally dominates level "L2". The "== 1" part of the query string indicates that if a match is found (match is `TRUE` or "== 1") then the ITEM of the level "L2" is returned. If this is expression is set to "== 0" (== `FALSE`), all the ITEMs that do not match the condition of "L2" will be returned. 

![Alt text](pics/positionSimple.svg)

Example **Q** & **A**'s:

- **Q**: *What is the query string to retrieve all word initial syllables?*
    - **A**: `"[Start(Word, Syllable) == 1]"`
- **Q**: *What is the query string to retrieve all word initial phonemes?*
    - **A**: `"[Start(Word, Phoneme) == 1]"`
- **Q**: *What is the query string to retrieve all syllables not at begining of word?* 
    - **A**: `"[Start(Word, Syllable) == 0]"`
- Functions Medial(La, Lb) and End(La, Lb)
- Word-final syllables "`[End(Word, Syllable) == 1]"` and so on  

### Position and Boolean &
Syntax: L = e & Start(La, Lb) = 1  
Semantics: Element e on level L occurs at the bginning of La  
Condition: La dominates Lb  (L and Lb are on the same level or linear level).  

- All /p/ phonemes at the beginning of a syllable  `"[Phoneme == p & Start(Syllable, Phoneme) == 1]"`  
- All word-final /m/ phonemes `"[Phoneme = m & End(Word, Phoneme)=1]"`
- All non-word-final "S"" syllables which are labeled with tonic accent L+H\*  `"[Syllable =S & Pitch_Accent=L+H* & (Word, Syllable)=0]"`

### Position and Boolean ^
Syntax/Semantics as for 5.2, but:
If L und Lb are different levels (L dominates Lb, or Lb dominates L) use ^ instead of & :

- /p/ phonemes, which occur in the first syllable of the word  `"[Phoneme = p ^ Start(Word, Syllable)=1]"`
- All phonemes, which do not occur in the last syllable of the word `"[Phoneme !=x ^ End(Word, Syllable)=0]"`

## Count

Syntax: **Num(La, Lb) = n**
Semantics: La contains n Lb elements
Condition: La dominates Lb. n is a number
Note: Generates segment list on La (not on Lb, as with 4-syllable words position)
**`[Num(Word, Syllable)=4]`**  
There are also the operators > (more than), < (less than) and != (not equal).  
Syllables, which have more than 6 phonemes
**`[Num(Syllable, Phoneme)>6]`**  
and so on  

### Count and Boolean &

Syntax: **L = e & Num(La, Lb) = n**  
Semantics: Element e on level L is dominated by La ; and La contains n Lb elements, La dominates Lb  
Condition: (L and La (not Lb!) are on the same level or linear level).  

- Text of all words, which consist of 11 phonemes: `"[Text!=x & Num(Text, Phoneme) > 11 ] ="` or  `"[Text =~ .* & Num(Word, Phoneme) > 11]"`
- H\* tonic accents in syllables of 5 phonemes:  `"[Pitch_Accent = H* & Num(Syllable, Phoneme) = 5]"`

### Count and ^

Syntax/Semantics as with 6.2, but:
If L and La are different levels (L dominates La, or La dominates L) use ^ instead of & :

- All m phonemes in 4-syllable words  `"[Phoneme == m ^ Num(Word, Syllable) == 4]"`
- All W-Syllables in words of 3 or less syllables `"[Syllable = W ^ Num(Word, Syllable) < 3]"`
- All words, which contain syllable, which contain 4 phonemes  `[Text != x ^ Num(Syllable, Phoneme) == 4]"`

## Combinations

### ^ and -> (Domination and Sequence)  
Condition: The sequence -> must connect only same or levels or linear levels! (See 2.)
`"[[a1 ^ a2] -> a3] [a1 -> [a2 ^ a3]]"`

- m precedes I and m is part of a S-syllable  `"[[Phoneme = m -> Phoneme = I] ^ Syllable=S]"`
- s precedes p and p is part of a W-syllable  `"[Phoneme = s -> [Phoneme = p ^ Syllable = W]]"`
- all S-syllables, which contain phoneme p and precede a S-syllable  `"[[Syllable = S ^ Phoneme = p] -> Syllable = S]"`
- but now we want p: p is part of a S-syllable and this S-syllable precedes a S-syllable: `"[[Phoneme = p ^ Syllable = S] -> Syllable = S]"`
- Not allowed! Because Phoneme = p and Syllable = S are not on the same level, therefore:  `"[[Syllable = S ^ #Phoneme=p] -> Syllable = S]"`

### ^ and -> and & (Domination and Sequence and Boolean &)

Words, beginning with a schwa:  
**`[Text!=x ^ Phoneme = @ & Start(Text, Phoneme)=1]`**
A word-begining m in a string syllbale, which precedes I  
**`[[Phoneme = m & Start(Word, Phoneme)=1 -> Phoneme=I] ^ Syllable=S]`**  
same but we want the text:  
**`[[[Phoneme = m & Start(Word, Phoneme)=1 -> Phoneme=I] ^ Syllable=S] ^ #Text!=x]`**
The text of all three-syllable words, which contain a schwa in the first syllable; these three-syllable words must precede ‘the’
The text of all three-syllable words  
1. Text!=x & Num(Text, Syllable)=3  
Schwa occurs in the first syllable  
2. Phoneme=@ ^ Start(Word, Syllable)=1  
The text is ‘the’  
3. Text = the  
[1 ^ 2]  
[[1 ^ 2] -> 3]

**`[[Text!=x & Num(Text, Syllable) =3 ^ [Phoneme=@ ^ Start(Word, Syllable)=1]] -> Text=the ]`**  

## A few more Q & A's

To revisit the various points lets go through a few typical questions and their respective answers.

- **Q**: m or n phonemes, which occur in the middle of the word.  
    - **A**: `"[Phoneme == m | n & Medial(Word, Phoneme) = 1]"`
- **Q**: [H] phonetic segments, next an arbitrary segment, next either [I] or [U].
    - **A**: `"[ [Phonetic == H -> Phonetic != x ] -> Phonetic == I | U ]"
- **Q**: Syllables, which do not occur in the middle of a word.
    - **A**: `[Syllable != x & Medial(Word, Syllable) == 0]`
- **Q**: The text of all words, which contain two syllables.  
    - **A**: `[Text != x & Num(Text, Syllable) == 2]`  
- **Q**: The text of all accentuated words following ‘the’.  
    - **A**: `[Text == the -> #Text != x & Accent == S]`
- **Q**: S syllables consisting of 5 phonemes.  
    - **A**: `[Syllable = S ^ Num(Word, Phoneme) == 5]`
- **Q**: W syllables, which contain a /@/ phoneme.
    - **A**: `[Syllable == W ^ Phoneme == @]`
- **Q**: The text of words, which contain either a L\* or L\+H\* a tonic accent.  
    - **A**: `[Text != x ^ Pitch_Accent = L* | L+H*]`
- **Q**: H\* tonic accents of word-final syllables, which occur in three-syllable words.  
    - **A**: `[Pitch_Accent = H* & End(Word, Syllable)=1 ^ Num(Word, Syllable) =3]`
- **Q**: All phonemes, dominating Phonetic element [H], at the beginning of a syllable; and which occur in accentuated (S) words.  
    - **A**: `[[[Phoneme!=x ^ Phonetic = H] ^ Start(Word, Syllable)=1] ^ Accent = S]`  


# Differences and incompatibilities to legacy EMU query language (R package 'emu', version 4.2)

## Function call syntax
For emuR it is required that the emuDB is loaded in current R session using function load_emuDB.

EQL2 query function is part of R package emuR. See help(query)  
Examples:
```
query('andosl',"[Phoneme = p ^ Syllable = S]")
```
Session and bundle selection patterns are optional and expect regular expression patterns.

Example:
```
query('andosl',"[Phoneme = p ^ Syllable = S]",sessionPattern='000.',bundlePattern='msajc0[1-2].')
```

Parameter sessionPattern has no effect here (andosl is a legacy import emuDB and has only one dummy session '0000').  
Parameter bundlePattern selects all bundle names starting with 'msajc01' or 'msajc02'.


## Result type

Default result type of a query is an object of R S3 class 'emuRsegs'. The class inherits legacy Emu class 'emusegs' and R standard class 'data.frame'. That means it is mostly compatible to the legacy seglist, but contains some additional data, e.g. the ID's of start and end item of each segment.
Each row of this data.frame is a sequence of one or more annotation elements on one level; a segment.   
Details:
```
help(emuRsegs)
```
emuR returns an empty segment list (zero row count) if the query does not match any element, in opposite to legacy Emu which throws an error: ("Can't find the query results in emu.query: there may have been a problem with the query command.")


## Bundle (utterance) names

emuR package arranges bundles (utterances) in sessions. Converted legacy EMU databases have one default session '0000' containing all bundles. Therefore the 'utts' column of all segment lists is prefixed by the session name and starts with '0000:' for example '0000:msajc003'.
See emuDB vignette for details.

## The result modifier hash tag '#'

Legacy Emu allows multiple occurences of the hash tag '#' in a query.

emuR allows only one single hash tag '#' in a query.

If you want multiple results in one segment list, it is recommended do concatenate the results of separate queries and position the hash tag to different places in these queries to get desired results.

## Interpretation of the hash character '#' in logical AND combined terms
#### legacy Emu
```
> emu.query('andosl','*','[Text=spring & #Accent=S]')
moving data from Tcl to R
Read 1 records
segment  list from database:  andosl 
query was:  [Text=spring & #Accent=S] 
  labels    start      end     utts
1 spring 2288.959 2704.466 msajc094

> emu.query('andosl','*','[#Text=spring & #Accent=S]')
moving data from Tcl to R
Read 1 records
segment  list from database:  andosl 
query was:  [#Text=spring & #Accent=S] 
  labels    start      end     utts
1 spring 2288.959 2704.466 msajc094
```
The hash character has no effect to both queries

#### emuR
```
> query(andosl,"[Text=spring & #Accent=S]",resultType='emusegs')
segment  list from database:  andosl 
query was:  [Text=spring & #Accent=S] 
  labels    start      end          utts
1      S 2288.975 2704.475 0000:msajc094
```
Returns the same segment (same item), but with the label of the hashed attribute name.
The second legacy example is not valid in emuR query (two hash tags).

```
> query('andosl',"[#Text=spring & #Accent=S]")

 Error in query.database.eql.KONJA(dbConfig, qTrim) : 
  Only one hashtag allowed in linear query term: #Text=spring & #Accent=S 
```

EQL2 throws an error here, because to fulfill the request it would be necessary to return each item doubled to get both Text and Accent labels.  

## Probable bugs in legacy EMU EQL

### Alternative labels in not equal conditional query
Example:
#### (legacy) emu
```
> emu.query('ae','*',"[Text!=beautiful|futile ^ Phoneme=u:]")
moving data from Tcl to R
Read 4 records
segment  list from database:  ae 
query was:  [Text!=beautiful|futile ^ Phoneme=u:] 
     labels    start      end     utts
1       new  475.802  666.743 msajc057
2    futile  571.999 1091.000 msajc010
3        to 1091.000 1222.389 msajc010
4 beautiful 2033.739 2604.489 msajc003
```
I assume that the OR operator '|' is ignored in connection with the not equal operator '!='

#### emuR
```
> query(ae,"[Text!=beautiful|futile ^ Phoneme=u:]",resultType='emusegs')
segment  list from database:  ae 
query was:  [Text!=beautiful|futile ^ Phoneme=u:] 
  labels    start      end          utts
1     to 1091.025 1222.375 0000:msajc010
2    new  475.825  666.725 0000:msajc057
```

### Errors caused by missing blanks

Legacy Emu query requires blanks around some operators or brackets in some queries. If these blanks are missing compiler errors or even crashes will occur for some query strings. 

emuR accepts these queries without blanks.

### Order of result segment list
It is unknown if legacy Emu returns the seglist ordered.
emuR returns emuRsegs result lists ordered by UUID,session,bundle and sample start position and emusegs lists by the fields utts and start.

### Additional features

emuR accepts also the double equal character string '==' as equal operator.

emuR EQL2 has the capability to query labels by matching regular expressions using the '=~' (match) and '!~' (not match) operators.

#### Example
```
> query('andosl',"Text=~.*tz.*")
segment  list from database:  andosl 
query was:  Text=~.*tz.* 
   labels    start      end session   bundle startItemID endItemID type
1 blitzed 1586.875 2112.475    0000 msadb081          54        54 ITEM
2 blitzed 1540.225 2022.475    0000 msajc081          59        59 ITEM
```


# Extended Backus–Naur Form (EBNF)

EBNF adapted from [@john:2012a]. As the original EBNF was formulated in german a few of the abriviation terms (e.g. "DOMA" is german abriviation for "**Dom**inanz**a**bfrage") where translated into english abriviations (e.g. "DOMQ" is an english abriviation for "**dom**inance **q**uery").

## Terminal symbols of EQL2 (operators) and their meaning.

The terminal symbols described below are ordered descending by their binding priority.

| Operator | Meaning |
| --- | --- |
| `#` | Result modifier (projection) |
| `,` | Parameter list separator |
| `==` | Equality (new in version 2 of the EQL; for cleaner syntax)|
| `=` | Equality (optional; for backwards compatibility)|
| `!=` | Unequality |
| `=~` | Regular expression match |
| `!~` | Regular expression not match |
| `>` | Greater than |
| `>=` | Equal or greater than  |
| `<` | Less than |
| `>=` | Equal or less than |
| `|` | Alternatives separator |
| `&` | Conjunction of equal rank |
| `^` | Dominanceconjunction |
| `->` | Sequenceoperator |

## Terminal symbols of EQL2 (brackets) and their meaning.

| Bracket | Meaning |
| --- | --- |
| `'` | Quotes literal string |
| `(` | Function parameter list begin |
| `)` | Function parameter list end |
| `[` | Sequence or dominance enclosing begin bracket  |
| `]` | Sequence or dominance enclosing end bracket |

## Terminal symbols of EQL2 (functions) and their meaning

| Function | Meaning |
| --- | --- |
| `Start` | Start | 
| `Medial` | Medial |
| `End` | Final |
| `Num` | Count |

## Nearly complete formal description of EMU query language EQL2

| EBNF term | Meaning |
| --- | --- |



+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| EBNF term                                                                         | Abriviation                        | Conditions                                    |
+===================================================================================+====================================+===============================================+
| `EQL = CONJQ | SEQQ | DOMQ;`                                                      | **E**MU **Q**uery **L**anguage     |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `DOMQ = "[", ( CONJQ | DOMQ | SEQQ ), "^", ( CONJQ | DOMQ | SEQQ ), "]";`         | **dom**inance **q**uery            | levels must be hierarchically associated      |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `SEQQ = "[", ( CONJQ | SEQQ | DOMQ ), "->", ( CONJQ | SEQQ | DOMQ ), "]";`        | **seq**uential **q**uery           | levels must be linearly associated            |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `CONJQ = { "[" }, SQ, { "&", SQ }, { "]" };`                                      | **conj**unction **q**uery          | levels must be linearly associated            |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `SQ = LABELQ | FUNCQ;`                                                            | *s*imple *q*uery                   |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABELQ = [ "#" ], LEVEL, ( "=" | "==" | "!=" | "=~" | "!~" ), LABELALTERNATIVES;`| **label** **q**uery                |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `FUNCQ = POSQ | NUMQ;`                                                            | **fun**ction **q**uery             |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `POSQ = POSFCT, "(", LEVEL, ",", LEVEL, ")", "=", "0" | "1";`                     | **position** **q**uery             | levels must be hierarchically associated;     |
|                                                                                   |                                    | second level determines semantic              |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `NUMQ = "Num", "(", LEVEL, ",", LEVEL, ")", VOP, INTPN;`                          | **number**  **q**uery              | levels must be hierarchically associated;     |
|                                                                                   |                                    | first level determines semantic               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABELALTERNATIVES = LABEL , { "|", LABEL };`                                     | **label alternatives**             |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `LABEL= LABELING | ( "'", LABELING, "'" );`                                       | **label**                          | levels must be part of the database structure;|
|                                                                                   |                                    | LABELING is an arbitrary character string or a|
|                                                                                   |                                    | label group class configured in the emuDB;    |
|                                                                                   |                                    | result modifier '#' may only occur once       |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `POSFCT = "Start" | "Medial" | "End";`                                            | **pos**ition **f**un**ct**ion      |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `VOP = "="" | "==" | "!=" | ">" | "<" | "<=" | ">=";`                             |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `INTPN = "0"" | INTP;`                                                            |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `INTP = DIGIT-"0", { DIGIT };`                                                    |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+
| `DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";`              |                                    |                                               |
+-----------------------------------------------------------------------------------+------------------------------------+-----------------------------------------------+



## Limitations 

A query can only contain a single result modifier "#" (hash tag)


# References